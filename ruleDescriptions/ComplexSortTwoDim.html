<html>

<head>
<title>Sort Complex (Fractal Rain)</title>
</head>

<body>
<p><b>Sort Complex (Fractal Rain)</b></p>
<p>Sorts complex numbers in two dimensions by swapping adjacent pairs that are out of order.  
First sorts the imaginary components (up-down), and then sorts the real components (right left).
Finally (be patient), the numbers are sorted simultaneously in all directions (up-down, right-left, 
and diagonal). 
</p>
<p>
Sorting complex numbers into two-dimensional space gives poorly defined results. For example, if two 
numbers are the same, then how should they be arranged in space? Next to each other, certainly. But 
should the duplicated number be above, below, or to the side? And what if there are lots of closely spaced small values 
like 0.01 + 0.01 i, and then there is another cluster of much larger numbers 
like 10.0 + 10.0 i? How should these be optimally sorted 
and arranged on a finite-sized square grid without leaving holes between the clusters?  
(Minimizing entropy is probably best, but this is not a unique solution.) Due to these ambiguities, 
there is no single correct solution, and some algorithms will produce &quot;better looking&quot; answers 
than others.
</p>
<p>
To illustrate that this sorting algorithm does a good job, the cells are color-coded by their 
rate of divergence from the Mandelbrot set (in other words, the standard color coding for 
displaying Mandelbrot sets).  If the numbers are randomly distributed (start with a 99% random initial state), 
then a reasonable reproduction of the Mandelbrot set 
means that the sorting algorithm has done a good job. In particular, dark colors are on the Mandelbrot 
set, and increasingly light colors are diverging more rapidly from the set.  In other words, colors are 
derived from the equation z = z<sup>2</sup> + c where z (the value of the cell) is iterated repeatedly. 
If the value diverges, the cell is given a light (or empty) color.  If the value 
converges, the cell is given a dark (or full) color.  The rate at which it diverges 
determines shades in between -- the faster the divergence then the lighter the color, 
and the slower the divergence then the darker the color. See the <a href="Fractal.html">Fractal</a> 
rule for another example of this coloring scheme.
</p>
<p>
Among other things, sorting is a problem in &quot;mass conservation&quot;. The 
numbers that are in the list must not &quot;disappear&quot; over time. The Margolus 
lattice is often used for problems in physics because it is particularly good at conserving 
quantities like mass.  Likewise, this sorting algorithm uses a Margolus lattice to 
&quot;conserve the numbers&quot;. See the square (Margolus) lattice 
tooltip for more details, but essentially, every square of adjacent four numbers is placed within a 
&quot;block&quot;. Numbers within a block are swapped when out of order. 
</p>
<p>
How fast is this sort?  Adjacent pair swapping algorithms are notoriously slow, typically O(N<sup>2</sup>). 
However, CA run in parallel, swapping all blocks simultaneously.  Therefore, this algorithm runs 
relatively fast. It is O(N) in each of the directions (right-left and up-down). If there are n rows and m 
rows, experimentation shows that this algorithm sorts in slightly longer than O(n+m) on average.  With 
somewhat poorer looking results, it is faster by a factor of 3 to just sort simultaneously in all directions 
without presorting up-down and right-left.
</p>
<p>
See <a href="RealSort.html">Sort Reals</a> for more details on the specific sorting algorithm 
used to presort the imaginary (and then real) components.
</p>
<p>
For more details on sorting algorithms and big-O growth rates like O(N), see my 
<a href="http://academic.regis.edu/dbahr/GeneralPages/DataStructures.htm">Data Structures</a> notes.
</p>
</body>

</html>